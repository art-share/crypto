import{scryptAsync as n,scrypt as t}from"@noble/hashes/scrypt";import{randomBytes as e}from"@noble/hashes/utils";const r={development:{N:16384,r:8,p:1,dkLen:32},standard:{N:65536,r:8,p:1,dkLen:32},high:{N:2**18,r:8,p:1,dkLen:32},paranoid:{N:2**20,r:8,p:1,dkLen:32}},o="standard",a=r[o],i=32,s={MIN_N:1024,MAX_N:2**24,MIN_R:1,MAX_R:64,MIN_P:1,MAX_P:64,MIN_DKLEN:16,MAX_DKLEN:128},u="1.0.0",c=["scrypt"];function d(n){return Array.from(n).map(n=>n.toString(16).padStart(2,"0")).join("")}function f(n){if(n.length%2!=0)throw new Error("Invalid hex string: odd length");const t=new Uint8Array(n.length/2);for(let e=0;e<n.length;e+=2)t[e/2]=parseInt(n.slice(e,e+2),16);return t}function h(){return d(e(32))}function p(){return d(e(16))}function w(n){const{N:t,r:e,p:r,dkLen:o}=n;if(t<=0||t&t-1)throw new Error("N must be a power of 2");if(t<s.MIN_N||t>s.MAX_N)throw new Error(`N must be between ${s.MIN_N} and ${s.MAX_N}`);if(e<s.MIN_R||e>s.MAX_R)throw new Error(`r must be between ${s.MIN_R} and ${s.MAX_R}`);if(r<s.MIN_P||r>s.MAX_P)throw new Error(`p must be between ${s.MIN_P} and ${s.MAX_P}`);if(o<s.MIN_DKLEN||o>s.MAX_DKLEN)throw new Error(`dkLen must be between ${s.MIN_DKLEN} and ${s.MAX_DKLEN}`);const a=128*t*e,i=1073741824;if(a>i)throw new Error(`Memory requirement (${Math.round(a/1024/1024)}MB) exceeds limit (1024MB)`)}function l(){const n="undefined"!=typeof process&&process.versions?.node,t="undefined"!=typeof window;return{webCrypto:"undefined"!=typeof crypto&&void 0!==crypto.subtle,secureContext:"undefined"!=typeof globalThis&&globalThis.isSecureContext||"undefined"!=typeof window&&window.isSecureContext||!0,nodeEnvironment:Boolean(n),browserEnvironment:t}}function N(n){const{N:t,r:e,p:r}=n,o=t/65536*200*(e/8)*r;return Math.round(o)}function M(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n.charCodeAt(r)^t.charCodeAt(r);return 0===e}function m(n,e,r=a){w(r);const o=e||h(),i=f(o);try{const e=t(n,i,r);return{hash:d(e),salt:o,params:r,timestamp:Date.now()}}finally{}}async function y(t,e,r=a){w(r);const o=e||h(),i=f(o);try{const e=await n(t,i,r);return{hash:d(e),salt:o,params:r,timestamp:Date.now()}}finally{}}async function _(n,t,e,r){try{return(await y(n,e,r)).hash===t}finally{}}function b(n){return{...r[n]}}function A(n="standard"){return{algorithm:"scrypt",params:b(n),salt:h(),formToken:p()}}async function E(n,t,e){return(await y(n,t,e)).hash}async function I(n,t,e=a){return(await y(n,t,e)).hash}export{a as DEFAULT_SCRYPT_PARAMS,o as DEFAULT_SECURITY_LEVEL,i as SALT_LENGTH,s as SCRYPT_LIMITS,r as SCRYPT_PRESETS,c as SUPPORTED_ALGORITHMS,u as VERSION,d as bytesToHex,E as clientHashPassword,A as createLoginParams,l as detectCryptoCapabilities,N as estimateHashingTime,p as generateFormToken,h as generateSalt,b as getScryptParams,y as hashPassword,m as hashPasswordSync,f as hexToBytes,I as serverHashPassword,M as timingSafeEqual,w as validateScryptParams,_ as verifyPassword};
//# sourceMappingURL=node.js.map
