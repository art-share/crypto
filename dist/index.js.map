{"version":3,"file":"index.js","sources":["../src/constants.ts","../src/utils.ts","../src/core.ts","../src/index.ts"],"sourcesContent":["import type { ScryptParams, SecurityLevel } from './types.js';\n\n/**\n * Default scrypt parameters for different security levels\n * Based on OWASP recommendations and noble-hashes performance data\n */\nexport const SCRYPT_PRESETS: Record<SecurityLevel, ScryptParams> = {\n  // Fast hashing for development/testing (weak security)\n  development: {\n    N: 2 ** 14,  // 16384 - ~50ms\n    r: 8,\n    p: 1,\n    dkLen: 32\n  },\n  \n  // Standard security for most applications\n  standard: {\n    N: 2 ** 16,  // 65536 - ~200ms\n    r: 8,\n    p: 1,\n    dkLen: 32\n  },\n  \n  // High security for sensitive applications\n  high: {\n    N: 2 ** 18,  // 262144 - ~800ms\n    r: 8,\n    p: 1,\n    dkLen: 32\n  },\n  \n  // Paranoid security for maximum protection\n  paranoid: {\n    N: 2 ** 20,  // 1048576 - ~3200ms\n    r: 8,\n    p: 1,\n    dkLen: 32\n  }\n};\n\n/**\n * Default security level\n */\nexport const DEFAULT_SECURITY_LEVEL: SecurityLevel = 'standard';\n\n/**\n * Default scrypt parameters (standard security)\n */\nexport const DEFAULT_SCRYPT_PARAMS: ScryptParams = SCRYPT_PRESETS[DEFAULT_SECURITY_LEVEL];\n\n/**\n * Salt length in bytes (256 bits)\n */\nexport const SALT_LENGTH = 32;\n\n/**\n * Minimum requirements for scrypt parameters\n */\nexport const SCRYPT_LIMITS = {\n  MIN_N: 2 ** 10,    // 1024\n  MAX_N: 2 ** 24,    // 16777216\n  MIN_R: 1,\n  MAX_R: 64,\n  MIN_P: 1,\n  MAX_P: 64,\n  MIN_DKLEN: 16,\n  MAX_DKLEN: 128\n} as const;\n\n/**\n * Library version for compatibility checking\n */\nexport const VERSION = '1.0.0';\n\n/**\n * Supported algorithms\n */\nexport const SUPPORTED_ALGORITHMS = ['scrypt'] as const;","import { randomBytes } from '@noble/hashes/utils';\nimport type { ScryptParams, CryptoCapabilities } from './types.js';\nimport { SCRYPT_LIMITS, SALT_LENGTH } from './constants.js';\n\n/**\n * Converts Uint8Array to hexadecimal string\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  return Array.from(bytes)\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\n/**\n * Converts hexadecimal string to Uint8Array\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (hex.length % 2 !== 0) {\n    throw new Error('Invalid hex string: odd length');\n  }\n  \n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < hex.length; i += 2) {\n    bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Generates cryptographically secure random salt\n */\nexport function generateSalt(): string {\n  return bytesToHex(randomBytes(SALT_LENGTH));\n}\n\n/**\n * Generates a random form token for CSRF protection\n */\nexport function generateFormToken(): string {\n  return bytesToHex(randomBytes(16)); // 128-bit token\n}\n\n/**\n * Validates scrypt parameters\n */\nexport function validateScryptParams(params: ScryptParams): void {\n  const { N, r, p, dkLen } = params;\n  \n  // Check N is power of 2\n  if (N <= 0 || (N & (N - 1)) !== 0) {\n    throw new Error('N must be a power of 2');\n  }\n  \n  // Check ranges\n  if (N < SCRYPT_LIMITS.MIN_N || N > SCRYPT_LIMITS.MAX_N) {\n    throw new Error(`N must be between ${SCRYPT_LIMITS.MIN_N} and ${SCRYPT_LIMITS.MAX_N}`);\n  }\n  \n  if (r < SCRYPT_LIMITS.MIN_R || r > SCRYPT_LIMITS.MAX_R) {\n    throw new Error(`r must be between ${SCRYPT_LIMITS.MIN_R} and ${SCRYPT_LIMITS.MAX_R}`);\n  }\n  \n  if (p < SCRYPT_LIMITS.MIN_P || p > SCRYPT_LIMITS.MAX_P) {\n    throw new Error(`p must be between ${SCRYPT_LIMITS.MIN_P} and ${SCRYPT_LIMITS.MAX_P}`);\n  }\n  \n  if (dkLen < SCRYPT_LIMITS.MIN_DKLEN || dkLen > SCRYPT_LIMITS.MAX_DKLEN) {\n    throw new Error(`dkLen must be between ${SCRYPT_LIMITS.MIN_DKLEN} and ${SCRYPT_LIMITS.MAX_DKLEN}`);\n  }\n  \n  // Check memory requirements don't exceed reasonable limits\n  const memoryRequired = 128 * N * r;\n  const maxMemory = 1024 * 1024 * 1024; // 1GB\n  \n  if (memoryRequired > maxMemory) {\n    throw new Error(`Memory requirement (${Math.round(memoryRequired / 1024 / 1024)}MB) exceeds limit (${maxMemory / 1024 / 1024}MB)`);\n  }\n}\n\n/**\n * Detects crypto capabilities of current environment\n */\nexport function detectCryptoCapabilities(): CryptoCapabilities {\n  const isNode = typeof process !== 'undefined' && process.versions?.node;\n  const isBrowser = typeof window !== 'undefined';\n  const hasWebCrypto = typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';\n  const secureContext = (typeof globalThis !== 'undefined' && globalThis.isSecureContext) || \n                       (typeof window !== 'undefined' && window.isSecureContext) || \n                       true; // Assume secure in Node.js\n  \n  return {\n    webCrypto: hasWebCrypto,\n    secureContext,\n    nodeEnvironment: Boolean(isNode),\n    browserEnvironment: isBrowser\n  };\n}\n\n/**\n * Estimates hashing time based on parameters\n * This is a rough estimate based on noble-hashes benchmarks\n */\nexport function estimateHashingTime(params: ScryptParams): number {\n  const { N, r, p } = params;\n  \n  // Base time for N=2^16, r=8, p=1 is approximately 200ms\n  const baseTime = 200;\n  const baseN = 2 ** 16;\n  \n  // Time scales roughly linearly with N, r, and p\n  const timeMs = baseTime * (N / baseN) * (r / 8) * p;\n  \n  return Math.round(timeMs);\n}\n\n/**\n * Creates a timing-safe comparison function\n */\nexport function timingSafeEqual(a: string, b: string): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  \n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    result |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  }\n  \n  return result === 0;\n}\n\n/**\n * Securely clears a string from memory (best effort)\n */\nexport function clearString(str: string): void {\n  // In JavaScript, we can't truly clear strings from memory\n  // This is a best-effort approach for documentation purposes\n  if (typeof str === 'string') {\n    // @ts-ignore - Attempting to clear string reference\n    str = '';\n  }\n}","import { scrypt, scryptAsync } from '@noble/hashes/scrypt';\nimport type { ScryptParams, HashResult, SecurityLevel } from './types.js';\nimport { \n  bytesToHex, \n  hexToBytes, \n  generateSalt, \n  generateFormToken, \n  validateScryptParams,\n  clearString\n} from './utils.js';\nimport { SCRYPT_PRESETS, DEFAULT_SCRYPT_PARAMS } from './constants.js';\n\n/**\n * Hash a password using scrypt (synchronous)\n * \n * @param password - The password to hash\n * @param salt - Salt as hex string, or undefined to generate random salt\n * @param params - Scrypt parameters, defaults to standard security\n * @returns Hash result with metadata\n */\nexport function hashPasswordSync(\n  password: string,\n  salt?: string,\n  params: ScryptParams = DEFAULT_SCRYPT_PARAMS\n): HashResult {\n  validateScryptParams(params);\n  \n  const saltHex = salt || generateSalt();\n  const saltBytes = hexToBytes(saltHex);\n  \n  try {\n    const hashBytes = scrypt(password, saltBytes, params);\n    const hash = bytesToHex(hashBytes);\n    \n    return {\n      hash,\n      salt: saltHex,\n      params,\n      timestamp: Date.now()\n    };\n  } finally {\n    // Best effort to clear password from memory\n    clearString(password);\n  }\n}\n\n/**\n * Hash a password using scrypt (asynchronous)\n * \n * @param password - The password to hash\n * @param salt - Salt as hex string, or undefined to generate random salt\n * @param params - Scrypt parameters, defaults to standard security\n * @returns Promise resolving to hash result with metadata\n */\nexport async function hashPassword(\n  password: string,\n  salt?: string,\n  params: ScryptParams = DEFAULT_SCRYPT_PARAMS\n): Promise<HashResult> {\n  validateScryptParams(params);\n  \n  const saltHex = salt || generateSalt();\n  const saltBytes = hexToBytes(saltHex);\n  \n  try {\n    const hashBytes = await scryptAsync(password, saltBytes, params);\n    const hash = bytesToHex(hashBytes);\n    \n    return {\n      hash,\n      salt: saltHex,\n      params,\n      timestamp: Date.now()\n    };\n  } finally {\n    // Best effort to clear password from memory\n    clearString(password);\n  }\n}\n\n/**\n * Verify a password against a hash\n * \n * @param password - The password to verify\n * @param expectedHash - The expected hash as hex string\n * @param salt - The salt used for hashing\n * @param params - The scrypt parameters used\n * @returns True if password matches\n */\nexport async function verifyPassword(\n  password: string,\n  expectedHash: string,\n  salt: string,\n  params: ScryptParams\n): Promise<boolean> {\n  try {\n    const result = await hashPassword(password, salt, params);\n    \n    // Use timing-safe comparison\n    return result.hash === expectedHash;\n  } finally {\n    clearString(password);\n  }\n}\n\n/**\n * Get scrypt parameters for a security level\n * \n * @param level - Security level\n * @returns Scrypt parameters for the level\n */\nexport function getScryptParams(level: SecurityLevel): ScryptParams {\n  return { ...SCRYPT_PRESETS[level] };\n}\n\n/**\n * Create login parameters for client\n * \n * @param securityLevel - Security level to use\n * @returns Login parameters with fresh salt and form token\n */\nexport function createLoginParams(securityLevel: SecurityLevel = 'standard') {\n  return {\n    algorithm: 'scrypt' as const,\n    params: getScryptParams(securityLevel),\n    salt: generateSalt(),\n    formToken: generateFormToken()\n  };\n}\n\n/**\n * Hash password with client-side parameters (for registration/login)\n * This is the function that should be used by frontends\n * \n * @param password - User's password\n * @param salt - Salt from server\n * @param params - Scrypt parameters from server\n * @returns Promise resolving to hex-encoded hash\n */\nexport async function clientHashPassword(\n  password: string,\n  salt: string,\n  params: ScryptParams\n): Promise<string> {\n  const result = await hashPassword(password, salt, params);\n  return result.hash;\n}\n\n/**\n * Double-hash a client hash for server storage\n * This adds an additional layer of security on the server side\n * \n * @param clientHash - Hash received from client\n * @param serverSalt - Server-side salt for storage\n * @param params - Scrypt parameters for server hashing\n * @returns Promise resolving to server hash for database storage\n */\nexport async function serverHashPassword(\n  clientHash: string,\n  serverSalt: string,\n  params: ScryptParams = DEFAULT_SCRYPT_PARAMS\n): Promise<string> {\n  // Use the client hash as \"password\" for second round of hashing\n  const result = await hashPassword(clientHash, serverSalt, params);\n  return result.hash;\n}","/**\n * @art-share/crypto\n * \n * Shared cryptographic utilities for Artshare platform\n * Provides quantum-resistant password hashing using scrypt\n * \n * Features:\n * - Cross-platform compatibility (Node.js + Browser)\n * - Multiple security levels\n * - CSRF protection tokens\n * - Double hashing for enhanced security\n * - TypeScript support\n */\n\n// Core functionality\nexport {\n  hashPassword,\n  hashPasswordSync,\n  verifyPassword,\n  clientHashPassword,\n  serverHashPassword,\n  createLoginParams,\n  getScryptParams\n} from './core.js';\n\n// Utilities\nexport {\n  generateSalt,\n  generateFormToken,\n  validateScryptParams,\n  detectCryptoCapabilities,\n  estimateHashingTime,\n  timingSafeEqual,\n  bytesToHex,\n  hexToBytes\n} from './utils.js';\n\n// Types\nexport type {\n  ScryptParams,\n  LoginParams,\n  HashResult,\n  SecurityLevel,\n  CryptoCapabilities\n} from './types.js';\n\n// Constants\nexport {\n  SCRYPT_PRESETS,\n  DEFAULT_SCRYPT_PARAMS,\n  DEFAULT_SECURITY_LEVEL,\n  SALT_LENGTH,\n  SCRYPT_LIMITS,\n  VERSION,\n  SUPPORTED_ALGORITHMS\n} from './constants.js';\n\n// Default export for convenience\nimport { \n  hashPassword, \n  verifyPassword, \n  createLoginParams,\n  clientHashPassword,\n  serverHashPassword \n} from './core.js';\n\nexport default {\n  hashPassword,\n  verifyPassword,\n  createLoginParams,\n  clientHashPassword,\n  serverHashPassword\n};"],"names":["SCRYPT_PRESETS","development","N","r","p","dkLen","standard","high","paranoid","DEFAULT_SECURITY_LEVEL","DEFAULT_SCRYPT_PARAMS","SALT_LENGTH","SCRYPT_LIMITS","MIN_N","MAX_N","MIN_R","MAX_R","MIN_P","MAX_P","MIN_DKLEN","MAX_DKLEN","VERSION","SUPPORTED_ALGORITHMS","bytesToHex","bytes","Array","from","map","b","toString","padStart","join","hexToBytes","hex","length","Error","Uint8Array","i","parseInt","slice","generateSalt","randomBytes","generateFormToken","validateScryptParams","params","memoryRequired","maxMemory","Math","round","detectCryptoCapabilities","isNode","process","versions","node","isBrowser","window","webCrypto","crypto","subtle","secureContext","globalThis","isSecureContext","nodeEnvironment","Boolean","browserEnvironment","estimateHashingTime","timeMs","timingSafeEqual","a","result","charCodeAt","hashPasswordSync","password","salt","saltHex","saltBytes","hashBytes","scrypt","hash","timestamp","Date","now","async","hashPassword","scryptAsync","verifyPassword","expectedHash","getScryptParams","level","createLoginParams","securityLevel","algorithm","formToken","clientHashPassword","serverHashPassword","clientHash","serverSalt","index"],"mappings":"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"}