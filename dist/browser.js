import{scryptAsync as n,scrypt as t}from"@noble/hashes/scrypt";import{randomBytes as e}from"@noble/hashes/utils";const r={development:{N:16384,r:8,p:1,dkLen:32},standard:{N:65536,r:8,p:1,dkLen:32},high:{N:2**18,r:8,p:1,dkLen:32},paranoid:{N:2**20,r:8,p:1,dkLen:32}},o="standard",i=r[o],s=32,a={MIN_N:1024,MAX_N:2**24,MIN_R:1,MAX_R:64,MIN_P:1,MAX_P:64,MIN_DKLEN:16,MAX_DKLEN:128},u="1.0.0",c=["scrypt"];function f(n){return Array.from(n).map(n=>n.toString(16).padStart(2,"0")).join("")}function d(n){if(n.length%2!=0)throw new Error("Invalid hex string: odd length");const t=new Uint8Array(n.length/2);for(let e=0;e<n.length;e+=2)t[e/2]=parseInt(n.slice(e,e+2),16);return t}function w(){return f(e(32))}function l(){return f(e(16))}function h(n){const{N:t,r:e,p:r,dkLen:o}=n;if(t<=0||t&t-1)throw new Error("N must be a power of 2");if(t<a.MIN_N||t>a.MAX_N)throw new Error(`N must be between ${a.MIN_N} and ${a.MAX_N}`);if(e<a.MIN_R||e>a.MAX_R)throw new Error(`r must be between ${a.MIN_R} and ${a.MAX_R}`);if(r<a.MIN_P||r>a.MAX_P)throw new Error(`p must be between ${a.MIN_P} and ${a.MAX_P}`);if(o<a.MIN_DKLEN||o>a.MAX_DKLEN)throw new Error(`dkLen must be between ${a.MIN_DKLEN} and ${a.MAX_DKLEN}`);const i=128*t*e,s=1073741824;if(i>s)throw new Error(`Memory requirement (${Math.round(i/1024/1024)}MB) exceeds limit (1024MB)`)}function p(){const n="undefined"!=typeof process&&process.versions?.node,t="undefined"!=typeof window;return{webCrypto:"undefined"!=typeof crypto&&void 0!==crypto.subtle,secureContext:"undefined"!=typeof globalThis&&globalThis.isSecureContext||"undefined"!=typeof window&&window.isSecureContext||!0,nodeEnvironment:Boolean(n),browserEnvironment:t}}function N(n){const{N:t,r:e,p:r}=n,o=t/65536*200*(e/8)*r;return Math.round(o)}function m(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n.charCodeAt(r)^t.charCodeAt(r);return 0===e}function M(n,e,r=i){h(r);const o=e||w(),s=d(o);try{const e=t(n,s,r);return{hash:f(e),salt:o,params:r,timestamp:Date.now()}}finally{}}async function y(t,e,r=i){h(r);const o=e||w(),s=d(o);try{const e=await n(t,s,r);return{hash:f(e),salt:o,params:r,timestamp:Date.now()}}finally{}}async function b(n,t,e,r){try{return(await y(n,e,r)).hash===t}finally{}}function _(n){return{...r[n]}}function A(n="standard"){return{algorithm:"scrypt",params:_(n),salt:w(),formToken:l()}}async function E(n,t,e){return(await y(n,t,e)).hash}async function I(n,t,e=i){return(await y(n,t,e)).hash}function g(){const n=p();return n.browserEnvironment&&n.secureContext&&n.webCrypto}function C(){const n=p();return{...n,isSecure:g(),recommendations:{webCrypto:n.webCrypto?null:"Web Crypto API not available",secureContext:n.secureContext?null:"Switch to HTTPS for secure context",browser:n.browserEnvironment?null:"Not running in browser"}}}export{i as DEFAULT_SCRYPT_PARAMS,o as DEFAULT_SECURITY_LEVEL,s as SALT_LENGTH,a as SCRYPT_LIMITS,r as SCRYPT_PRESETS,c as SUPPORTED_ALGORITHMS,u as VERSION,f as bytesToHex,E as clientHashPassword,A as createLoginParams,p as detectCryptoCapabilities,N as estimateHashingTime,l as generateFormToken,w as generateSalt,C as getBrowserCryptoStatus,_ as getScryptParams,y as hashPassword,M as hashPasswordSync,d as hexToBytes,g as isSecureBrowserEnvironment,I as serverHashPassword,m as timingSafeEqual,h as validateScryptParams,b as verifyPassword};
//# sourceMappingURL=browser.js.map
