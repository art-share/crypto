import{scryptAsync as n,scrypt as r}from"@noble/hashes/scrypt";import{randomBytes as t}from"@noble/hashes/utils";const e={development:{N:16384,r:8,p:1,dkLen:32},standard:{N:65536,r:8,p:1,dkLen:32},high:{N:2**18,r:8,p:1,dkLen:32},paranoid:{N:2**20,r:8,p:1,dkLen:32}},o="standard",a=e[o],s=32,i={MIN_N:1024,MAX_N:2**24,MIN_R:1,MAX_R:64,MIN_P:1,MAX_P:64,MIN_DKLEN:16,MAX_DKLEN:128},u="1.0.0",d=["scrypt"];function c(n){return Array.from(n).map(n=>n.toString(16).padStart(2,"0")).join("")}function f(n){if(n.length%2!=0)throw new Error("Invalid hex string: odd length");const r=new Uint8Array(n.length/2);for(let t=0;t<n.length;t+=2)r[t/2]=parseInt(n.slice(t,t+2),16);return r}function h(){return c(t(32))}function w(){return c(t(16))}function l(n){const{N:r,r:t,p:e,dkLen:o}=n;if(r<=0||r&r-1)throw new Error("N must be a power of 2");if(r<i.MIN_N||r>i.MAX_N)throw new Error(`N must be between ${i.MIN_N} and ${i.MAX_N}`);if(t<i.MIN_R||t>i.MAX_R)throw new Error(`r must be between ${i.MIN_R} and ${i.MAX_R}`);if(e<i.MIN_P||e>i.MAX_P)throw new Error(`p must be between ${i.MIN_P} and ${i.MAX_P}`);if(o<i.MIN_DKLEN||o>i.MAX_DKLEN)throw new Error(`dkLen must be between ${i.MIN_DKLEN} and ${i.MAX_DKLEN}`);const a=128*r*t,s=1073741824;if(a>s)throw new Error(`Memory requirement (${Math.round(a/1024/1024)}MB) exceeds limit (1024MB)`)}function p(){const n="undefined"!=typeof process&&process.versions?.node,r="undefined"!=typeof window;return{webCrypto:"undefined"!=typeof crypto&&void 0!==crypto.subtle,secureContext:"undefined"!=typeof globalThis&&globalThis.isSecureContext||"undefined"!=typeof window&&window.isSecureContext||!0,nodeEnvironment:Boolean(n),browserEnvironment:r}}function N(n){const{N:r,r:t,p:e}=n,o=r/65536*200*(t/8)*e;return Math.round(o)}function M(n,r){if(n.length!==r.length)return!1;let t=0;for(let e=0;e<n.length;e++)t|=n.charCodeAt(e)^r.charCodeAt(e);return 0===t}function m(n,t,e=a){l(e);const o=t||h(),s=f(o);try{const t=r(n,s,e);return{hash:c(t),salt:o,params:e,timestamp:Date.now()}}finally{}}async function y(r,t,e=a){l(e);const o=t||h(),s=f(o);try{const t=await n(r,s,e);return{hash:c(t),salt:o,params:e,timestamp:Date.now()}}finally{}}async function _(n,r,t,e){try{return(await y(n,t,e)).hash===r}finally{}}function b(n){return{...e[n]}}function A(n="standard"){return{algorithm:"scrypt",params:b(n),salt:h(),formToken:w()}}async function E(n,r,t){return(await y(n,r,t)).hash}async function g(n,r,t=a){return(await y(n,r,t)).hash}var I={hashPassword:y,verifyPassword:_,createLoginParams:A,clientHashPassword:E,serverHashPassword:g};export{a as DEFAULT_SCRYPT_PARAMS,o as DEFAULT_SECURITY_LEVEL,s as SALT_LENGTH,i as SCRYPT_LIMITS,e as SCRYPT_PRESETS,d as SUPPORTED_ALGORITHMS,u as VERSION,c as bytesToHex,E as clientHashPassword,A as createLoginParams,I as default,p as detectCryptoCapabilities,N as estimateHashingTime,w as generateFormToken,h as generateSalt,b as getScryptParams,y as hashPassword,m as hashPasswordSync,f as hexToBytes,g as serverHashPassword,M as timingSafeEqual,l as validateScryptParams,_ as verifyPassword};
//# sourceMappingURL=index.js.map
